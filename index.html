<!doctype html>
<html>
  <head>
        <!-- Sprint1
            Caricamento oggetto 3d da file
            Gestione luce
            Gestione colori
            Gestione trasformazioni geometriche sull'oggetto
            Gestione Camera, punto di vista
            ----------------------------------------------
            esempi utilizzati:
            Esercizio8 CubeMeshObj
            WebGl_code3/cg_car2.html
            WebGl_code2/webgl-3d-lighting-point.html
            WebGl_code2/gc_webgl-multiple-objects-list
         -->
        <!-- Sprint2 (NON FINITO)
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/cube_shading
         -->
        <!-- Sprint3 
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/webgl-shadows-w-spot-light
         -->

      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <link rel="stylesheet" type="text/css" href="css/style.css">
      <title>WebGLMiniArcade</title> 

      
   </head>
   
    <body>
        <div id="container" >            
            <canvas id="gamePanel"></canvas>
            <canvas id="controlPanel"></canvas>
        </div>       
        <div id="loading">
                <h1>CARICAMENTO IN CORSO...</h1>
        </div>

        <!-- WebGLControllerV2 -----INIZIO-->
       <script  id="3d-vertex-shader" type="x-shader/x-vertex">
            //uniform mat4 Mmatrix;   

            attribute vec4 a_position;
            attribute vec2 a_texcoord;
            attribute vec3 a_normal;
            
         
            uniform vec3 u_viewWorldPosition;


            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_world;      
            uniform mat4 specchioMatrix;
            

            varying vec2 v_texcoord;
            varying vec3 v_normal;

 
            varying vec3 v_surfaceToView;
            //-------------------------------------------------------------------LUCI Mondo
            uniform mat4 u_textureMatrix_m1;            
            varying vec4 v_projectedTexcoord_m1;              
            uniform vec3 u_lightWorldPosition_m1;
            uniform mat4 u_textureMatrix_m2;            
            varying vec4 v_projectedTexcoord_m2;              
            uniform vec3 u_lightWorldPosition_m2;
            uniform mat4 u_textureMatrix_m3;           
            varying vec4 v_projectedTexcoord_m3;             
            uniform vec3 u_lightWorldPosition_m3;
           
            varying vec3 v_surfaceToLight_m1;
            varying vec3 v_surfaceToLight_m2;
            varying vec3 v_surfaceToLight_m3;

            //-------------------------------------------------------------------LUCI AUTO
            uniform vec3 u_lightWorldPosition_AD;
            varying vec3 v_surfaceToLight_AD;
            uniform vec3 u_lightWorldPosition_AS;
            varying vec3 v_surfaceToLight_AS;
            
         

            uniform vec3 u_lightWorldPosition_AD_sup;
            varying vec3 v_surfaceToLight_AD_sup;
            uniform vec3 u_lightWorldPosition_AS_sup;
            varying vec3 v_surfaceToLight_AS_sup;

            uniform vec3 u_lightWorldPosition_PD_sup;            
            uniform vec3 u_lightWorldPosition_PS_sup;            
            varying vec3 v_surfaceToLight_PS_sup;            
            varying vec3 v_surfaceToLight_PD_sup;

            //ombre
            uniform mat4 u_textureMatrix_1;            
            varying vec4 v_projectedTexcoord_1;            
            uniform mat4 u_textureMatrix_2;            
            varying vec4 v_projectedTexcoord_2;            
            uniform mat4 u_textureMatrix_3;            
            varying vec4 v_projectedTexcoord_3;            
            uniform mat4 u_textureMatrix_4;            
            varying vec4 v_projectedTexcoord_4;                     
            uniform mat4 u_textureMatrix_5;            
            varying vec4 v_projectedTexcoord_5;         
            uniform mat4 u_textureMatrix_6;            
            varying vec4 v_projectedTexcoord_6;
            //----------------------------------------------------------------------------

            void main() {
            mat4 internal_u_world =u_world * specchioMatrix;
            // Multiply the position by the matrix.
            vec4 worldPosition = internal_u_world * a_position;

            gl_Position = u_projection * u_view * specchioMatrix  * worldPosition;
            //gl_Position = u_projection * u_view * specchioMatrix  * Mmatrix * worldPosition;

            // Pass the texture coord to the fragment shader.
            v_texcoord = a_texcoord;

            v_projectedTexcoord_m1 = u_textureMatrix_m1 * worldPosition;
            v_projectedTexcoord_m2 = u_textureMatrix_m2 * worldPosition;
            v_projectedTexcoord_m3 = u_textureMatrix_m3 * worldPosition;

            // orient the normals and pass to the fragment shader
            v_normal = mat3(internal_u_world ) * a_normal;

            // compute the world position of the surface
            vec3 surfaceWorldPosition = (internal_u_world * a_position).xyz;

            // compute the vector of the surface to the light
            // and pass it to the fragment shader
            v_surfaceToLight_m1 = u_lightWorldPosition_m1 - surfaceWorldPosition;            
            v_surfaceToLight_m2 = u_lightWorldPosition_m2 - surfaceWorldPosition;            
            v_surfaceToLight_m3 = u_lightWorldPosition_m3 - surfaceWorldPosition;

            // compute the vector of the surface to the view/camera
            // and pass it to the fragment shader
            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;

            //-------------------------------------------------------------------LUCI AUTO
            v_surfaceToLight_AD = u_lightWorldPosition_AD - surfaceWorldPosition;
            v_surfaceToLight_AS = u_lightWorldPosition_AS - surfaceWorldPosition;
            v_surfaceToLight_AD_sup = u_lightWorldPosition_AD_sup - surfaceWorldPosition;
            v_surfaceToLight_AS_sup = u_lightWorldPosition_AS_sup - surfaceWorldPosition;
            v_surfaceToLight_PD_sup = u_lightWorldPosition_PD_sup - surfaceWorldPosition;
            v_surfaceToLight_PS_sup = u_lightWorldPosition_PS_sup - surfaceWorldPosition;
            //---ombre (fari auto)
            v_projectedTexcoord_1 = u_textureMatrix_1 * worldPosition;            
            v_projectedTexcoord_2 = u_textureMatrix_2 * worldPosition;
            v_projectedTexcoord_3 = u_textureMatrix_3 * worldPosition;
            v_projectedTexcoord_4 = u_textureMatrix_4 * worldPosition;
            v_projectedTexcoord_5 = u_textureMatrix_5 * worldPosition;
            v_projectedTexcoord_6 = u_textureMatrix_6 * worldPosition;
            //----------------------------------------------------------------------------

            }
            </script>
            <!-- fragment shader -->
            <script  id="3d-fragment-shader" type="x-shader/x-fragment">
            precision mediump float;


            // Passed in from the vertex shader.
            varying vec2 v_texcoord;
            varying vec3 v_normal;
            varying vec3 v_surfaceToView;
            uniform vec4 u_colorMult;
            uniform sampler2D u_texture; 
            uniform float u_bias;
            uniform float u_shininess;

            

            uniform float blur_shadow;

            uniform float u_innerLimit;          // in dot space
            uniform float u_outerLimit;          // in dot space
            //
            uniform float illuminazione;

            //aggiunto per poter disegnare un oggetto senza texture
            uniform float texture_enable; 
            //aggiunto per poter calcolare un numero randomico 
            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            
            //-------------------------------------------------------------------LUCI Mondo
            varying vec3 v_surfaceToLight_m1;
            varying vec4 v_projectedTexcoord_m1;            
            uniform sampler2D u_projectedTexture_m1;      
            uniform vec3 u_lightDirection_m1;  

            varying vec3 v_surfaceToLight_m2;
            varying vec4 v_projectedTexcoord_m2;            
            uniform sampler2D u_projectedTexture_m2;   
            uniform vec3 u_lightDirection_m2;   

            varying vec3 v_surfaceToLight_m3;
            varying vec4 v_projectedTexcoord_m3;            
            uniform sampler2D u_projectedTexture_m3; 
            uniform vec3 u_lightDirection_m3;   

            //-------------------------------------------------------------------LUCI AUTO
            varying vec3 v_surfaceToLight_AD;        
            varying vec3 v_surfaceToLight_AS;  
            //uniform vec4 u_color_A;
            uniform float u_shininess_A;
            uniform vec4 u_lightColor_A;
            uniform vec4 u_lightColor_P;
            uniform vec3 u_specularColor_A;            
            uniform vec3 u_lightDirection_AS;                   
            uniform vec3 u_lightDirection_AD; 
            uniform float u_outerLimit_A;          
            uniform float u_innerLimit_A;    
            
            //superfice faro davanti
            varying vec3 v_surfaceToLight_AD_sup;
            varying vec3 v_surfaceToLight_AS_sup;
            uniform vec3 u_lightDirection_AD_sup;
            uniform vec3 u_lightDirection_AS_sup;
            //superfice faro posteriore
            varying vec3 v_surfaceToLight_PD_sup;
            varying vec3 v_surfaceToLight_PS_sup;
            uniform vec3 u_lightDirection_PD_sup;
            uniform vec3 u_lightDirection_PS_sup;

            //ombre
            uniform sampler2D u_projectedTexture_1;            
            varying vec4 v_projectedTexcoord_1;            
            uniform sampler2D u_projectedTexture_2;            
            varying vec4 v_projectedTexcoord_2;            
            uniform sampler2D u_projectedTexture_3;            
            varying vec4 v_projectedTexcoord_3;            
            uniform sampler2D u_projectedTexture_4;            
            varying vec4 v_projectedTexcoord_4;    
            uniform sampler2D u_projectedTexture_5;            
            varying vec4 v_projectedTexcoord_5;    
            uniform sampler2D u_projectedTexture_6;            
            varying vec4 v_projectedTexcoord_6;    

            //----------------------------------------------------------------------------

            void main() {
                // because v_normal is a varying it's interpolated
                // so it will not be a unit vector. Normalizing it
                // will make it a unit vector again
                vec3 normal = normalize(v_normal);
                ///--------------------------------------------------------------------------------------LUCI MONDO
                float limitRange = u_innerLimit - u_outerLimit;
                //----- m1
                vec3 surfaceToLightDirection = normalize(v_surfaceToLight_m1);
                vec3 surfaceToViewDirection = normalize(v_surfaceToView);
                vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);  
                float dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection_m1);        
                float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.5, 1.0);
                float light_m1 = inLight * dot(normal, surfaceToLightDirection);
                float specular = inLight * pow(dot(normal, halfVector), u_shininess);    
                vec3 projectedTexcoord = v_projectedTexcoord_m1.xyz / v_projectedTexcoord_m1.w;
                float currentDepth = projectedTexcoord.z + u_bias;    
                bool inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0;    
                // the 'r' channel has the depth values
                float projectedDepth = texture2D(u_projectedTexture_m1, projectedTexcoord.xy).r ;
                float shadowLight_m1 =(inRange && projectedDepth <= currentDepth) ? 1.0 : 0.0;
                //----- m2
                surfaceToLightDirection = normalize(v_surfaceToLight_m2);
                surfaceToViewDirection = normalize(v_surfaceToView);
                halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);  
                dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection_m2);        
                inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.5, 1.0);
                float light_m2 = inLight * dot(normal, surfaceToLightDirection);
                specular = inLight * pow(dot(normal, halfVector), u_shininess);    
                projectedTexcoord = v_projectedTexcoord_m2.xyz / v_projectedTexcoord_m2.w;
                currentDepth = projectedTexcoord.z + u_bias;    
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0;    
                // the 'r' channel has the depth values
                projectedDepth = texture2D(u_projectedTexture_m2, projectedTexcoord.xy).r ;
                float shadowLight_m2 =(inRange && projectedDepth <= currentDepth) ? 1.0 : 0.0;
                //----- m3
                surfaceToLightDirection = normalize(v_surfaceToLight_m3);
                surfaceToViewDirection = normalize(v_surfaceToView);
                halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);  
                dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection_m3);        
                inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.5, 1.0);
                float light_m3 = inLight * dot(normal, surfaceToLightDirection);
                specular = inLight * pow(dot(normal, halfVector), u_shininess);    
                projectedTexcoord = v_projectedTexcoord_m3.xyz / v_projectedTexcoord_m3.w;
                currentDepth = projectedTexcoord.z + u_bias;    
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0;    
                // the 'r' channel has the depth values
                projectedDepth = texture2D(u_projectedTexture_m3, projectedTexcoord.xy).r ;
                float shadowLight_m3 =(inRange && projectedDepth <= currentDepth) ? 1.0 : 0.0;

                ///-----------------------------------------------------------------------------------------------------------------------------------------------------------
               
                float shadowLight_1 =1.0;
                float shadowLight_2 =1.0;
                float shadowLight_3 =1.0;
                float shadowLight_4 =1.0;
                float shadowLight_5 =1.0;
                float shadowLight_6 =1.0;

                limitRange = (u_innerLimit_A - u_outerLimit_A);     
                //ombre luci auto
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione terreno)
                projectedTexcoord = v_projectedTexcoord_1.xyz / v_projectedTexcoord_1.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;                                     
                dotFromDirection = dot(normalize(v_surfaceToLight_AD),-u_lightDirection_AD);    
                float smorzatore_luce=1.0;
                if(dotFromDirection<0.0){                     
                    smorzatore_luce=0.0;
                }else{
                    smorzatore_luce=clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                }
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_1 = texture2D(u_projectedTexture_1, projectedTexcoord.xy).r ;
                shadowLight_1 =(inRange && projectedDepth_1 <= currentDepth) ? 1.0 : (1.0-smorzatore_luce);
                if(!inRange ){
                    shadowLight_1= 1.0;
                }
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione terreno)
                projectedTexcoord = v_projectedTexcoord_2.xyz / v_projectedTexcoord_2.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;              
                dotFromDirection = dot(normalize(v_surfaceToLight_AS),-u_lightDirection_AS);    
                if(dotFromDirection<0.0){                     
                    smorzatore_luce = 0.0;
                }else{
                    smorzatore_luce=clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                }
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_2 = texture2D(u_projectedTexture_2, projectedTexcoord.xy).r ;
                shadowLight_2 =(inRange && projectedDepth_2 <= currentDepth) ? 1.0 : (1.0-smorzatore_luce);
                if(!inRange){
                    shadowLight_2= 1.0;
                }
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione faro stesso)    
                projectedTexcoord = v_projectedTexcoord_3.xyz / v_projectedTexcoord_3.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_3 = texture2D(u_projectedTexture_3, projectedTexcoord.xy).r ;
                shadowLight_3 =(inRange && projectedDepth_3 <= currentDepth) ? 1.0 : 0.0;
                if(!inRange){
                    shadowLight_3= 1.0;
                }
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione faro stesso)
                projectedTexcoord = v_projectedTexcoord_4.xyz / v_projectedTexcoord_4.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_4 = texture2D(u_projectedTexture_4, projectedTexcoord.xy).r ;
                shadowLight_4 =(inRange && projectedDepth_4 <= currentDepth) ? 1.0 : 0.0;
                if(!inRange){
                    shadowLight_4= 1.0;
                }
                //-------------------------------------------------------------------LUCE AUTO DESTRA POSTERIORE (proiezione faro stesso)    
                projectedTexcoord = v_projectedTexcoord_5.xyz / v_projectedTexcoord_5.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_5 = texture2D(u_projectedTexture_5, projectedTexcoord.xy).r ;
                shadowLight_5 =(inRange && projectedDepth_5 <= currentDepth) ? 1.0 : 0.0;
                if(!inRange){
                    shadowLight_5= 1.0;
                }
                //-------------------------------------------------------------------LUCE AUTO SINISTRA POSTERIORE (proiezione faro stesso)
                projectedTexcoord = v_projectedTexcoord_6.xyz / v_projectedTexcoord_6.w;
                inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0 && 
                    projectedTexcoord.z >= 0.0 && 
                    projectedTexcoord.z <= 1.0 
                    ;
                currentDepth = projectedTexcoord.z + u_bias;
                float projectedDepth_6 = texture2D(u_projectedTexture_6, projectedTexcoord.xy).r ;
                shadowLight_6 =(inRange && projectedDepth_6 <= currentDepth) ? 1.0 : 0.0;
                if(!inRange){
                    shadowLight_6= 1.0;
                }
                 ///-----------------------------------------------------------------------------------------------------------------------------------------------------------
                
                //calcolo il risultato finale di tutte le luci sia del mondo che dell'auto
                float shadowLight=1.0+ ( 
                    - shadowLight_1 * 0.05  
                    - shadowLight_2 * 0.05 
                    - shadowLight_m1 * 0.3
                    - shadowLight_m2 * 0.3
                    - shadowLight_m3 * 0.3
                    );
               

                if(blur_shadow > 0.0){
                /*
                    //blur manuale delle ombre
                    //if(shadowLight>0.0){
                    //    //se il punto attuale non è un pezzo dell'ombra, aumento comunque la sua ombra in base alla distanza da altri px in ombra
                    //    float intensita = 0.0;
                    //    for(float x=0.0 ; x<0.001; x += 0.01){
                    //        for(float y=0.0; y<0.001; y += 0.01){
                    //            if((projectedTexcoord.x + x) < 1.0 && (projectedTexcoord.y + y) < 1.0){                            
                    //                vec4 temp_coord=vec4(projectedTexcoord.x+x,projectedTexcoord.y+y,projectedTexcoord.z,1.0);
                    //                float projectedDepth_2=texture2D(u_projectedTexture, temp_coord.xy).r;
                    //                intensita += (inRange && projectedDepth_2 <= currentDepth) ? 1.0 : 0.001;
                    //            }
                    //        }
                    //    }
                    //    shadowLight=shadowLight-intensita;
                    //}
                    //Poisson Sampling
                    vec2 poissonDisk_0 = vec2( -0.94201624, -0.39906216 );
                    vec2 poissonDisk_1 = vec2( 0.94558609, -0.76890725 );
                    vec2 poissonDisk_2 =  vec2( -0.094184101, -0.92938870 );
                    vec2 poissonDisk_3 = vec2( 0.34495938, 0.29387760 );
                    //-------------poisson blur
                    if(shadowLight > 0.0){
                        for (int i=0;i<16;i++){
                            float index = rand(gl_FragCoord.xy);
                            float temp=0.0;
                            if(index>0.2){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_0/blur_shadow ).r - currentDepth;                   
                            }else if(index>0.4){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_1/blur_shadow ).r - currentDepth;
                            }else if(index>0.6){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_2/blur_shadow ).r - currentDepth;
                            }else{
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_3/blur_shadow ).r - currentDepth;
                            }
                            if(temp<0.0){
                                shadowLight +=  temp  ;
                            }
                        }
                    }
                */
                }
         
                //aggiunto per poter disegnare un oggetto senza texture
                vec4 texColor = (texture_enable==0.0) ? (u_colorMult) : (texture2D(u_texture, v_texcoord) * u_colorMult);    
                //vec4 texColor =  u_colorMult;
                float light = illuminazione + (light_m1 + light_m2 + light_m3)/3.0;
                gl_FragColor = vec4(
                    texColor.rgb * light * shadowLight +
                    specular * shadowLight,
                    texColor.a);
        
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione terreno)
                if(shadowLight_1 < 1.0){
      
                    //-------------------
                    vec3 surfaceToLightDirection_AD = normalize(v_surfaceToLight_AD);
                    halfVector = normalize(surfaceToLightDirection_AD + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AD,-u_lightDirection_AD);      
                    inLight = clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AD);
                   // if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A) ;  
                        gl_FragColor += vec4(texColor.rgb * u_lightColor_A.rgb * light  +  specular * u_specularColor_A,texColor.a);   
                   //}
                }
                   
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione terreno)
                if(shadowLight_2 < 1.0){
                    vec3 surfaceToLightDirection_AS = normalize(v_surfaceToLight_AS);
                    halfVector = normalize(surfaceToLightDirection_AS + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AS,-u_lightDirection_AS);   
                    inLight = clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AS);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(texColor.rgb * u_lightColor_A.rgb * light +  specular * u_specularColor_A,texColor.a);
                    }
                }
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione faro stesso)
                if(shadowLight_3 < 1.0){
                    vec3 surfaceToLightDirection_AD_sup = normalize(v_surfaceToLight_AD_sup);
                    halfVector = normalize(surfaceToLightDirection_AD_sup + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AD_sup,- u_lightDirection_AD_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AD_sup);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                        gl_FragColor += vec4(u_lightColor_A.rgb * light +  specular * u_specularColor_A,u_lightColor_A.a);   
                    }
                }                
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione faro stesso)
                if(shadowLight_4 < 1.0){
                    vec3 surfaceToLightDirection_AS_supp = normalize(v_surfaceToLight_AS_sup);
                    halfVector = normalize(surfaceToLightDirection_AS_supp + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AS_supp,- u_lightDirection_AS_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AS_supp);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(u_lightColor_A.rgb * light +  specular * u_specularColor_A,u_lightColor_A.a);
                    }
                } 
                //-------------------------------------------------------------------LUCE AUTO DESTRA POSTERIORE (proiezione faro stesso)
                if(shadowLight_5 < 1.0){
                    vec3 surfaceToLightDirection_PD_sup = normalize(v_surfaceToLight_PD_sup);
                    halfVector = normalize(surfaceToLightDirection_PD_sup + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_PD_sup,- u_lightDirection_PD_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_PD_sup);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                        gl_FragColor += vec4(u_lightColor_P.rgb * light*2.0 +  specular * u_specularColor_A,u_lightColor_P.a);   
                    }
                }                
                //-------------------------------------------------------------------LUCE AUTO SINISTRA POSTERIORE (proiezione faro stesso)
                if(shadowLight_6 < 1.0){
                    vec3 surfaceToLightDirection_PS_supp = normalize(v_surfaceToLight_PS_sup);
                    halfVector = normalize(surfaceToLightDirection_PS_supp + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_PS_supp,- u_lightDirection_PS_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_PS_supp);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(u_lightColor_P.rgb * light*2.0 +  specular * u_specularColor_A,u_lightColor_P.a);
                    }
                }
                //----------------------------------------------------------------------------
              
          
                //}
               
    
            }
          
            </script>
        <script id="color-vertex-shader" type="x-shader/x-vertex">
                //uniform mat4 Mmatrix; 

                attribute vec4 a_position;
          

                uniform mat4 u_projection;
                uniform mat4 u_view;
                uniform mat4 u_world;
                
                void main() {
                  // Multiply the position by the matrices.
                  gl_Position = u_projection * u_view * u_world * a_position;
                  //gl_Position = u_projection * u_view * Mmatrix * u_world * a_position;
                }
        </script>
                <!-- fragment shader -->
        <script id="color-fragment-shader" type="x-shader/x-fragment">
                precision mediump float;
                
                uniform vec4 u_color;
                void main() {
                  gl_FragColor = u_color;
                }
         </script>
        <!-- WebGLControllerV2 -----FINE-->
        <script id="stencil-vertex-shader" type="x-shader/x-vertex">
            attribute vec4 a_position;

            uniform mat4 u_projection;
            uniform mat4 u_view;       
            uniform mat4 u_world;

            void main() 
            {
                gl_Position = u_projection*u_view*u_world*a_position;
            } 
        </script>
            
        <script id="stencil-fragment-shader" type="x-shader/x-fragment">
            precision mediump float;


            void main()
            {
                gl_FragColor = vec4(1.0,0.0,0.0,1.0);
            }
         </script>
   
    </body>




    
    <script type="text/javascript" src="lib/utility.js"></script>
    <script type="text/javascript" src="lib/Panel2D.js"></script>
    <script type="text/javascript" src="lib/WebGLController.js"></script>    
    <script type="text/javascript" src="lib/Obj3D.js"></script>    
    <script type="text/javascript" src="lib/Car.js"></script>        
    <script type="text/javascript" src="lib/Ombre.js"></script>
    <script type="text/javascript" src="lib/Pista.js"></script>
    <script type="text/javascript" src="lib/Mondo.js"></script>    
    <script type="text/javascript" src="lib/GameBehavior.js"></script>

    <script type="text/javascript" src="resources/subdiv.js"></script>
  <script type="text/javascript" src="resources/mesh_utils.js"></script>
  <script type="text/javascript" src="resources/webgl-utils.js"></script>
  <script type="text/javascript" src="resources/m4.js"></script>      
  <script  type="text/javascript" src="resources/glm_light.js"></script>
  <script type="text/javascript" src="resources/primitives.js"></script>
  <script type="text/javascript" src="resources/anmglib.js"></script>

  <script type="text/javascript" src="webgl-debug.js"></script>

    <script type="text/javascript">
        function dinamicResize(){
            var cp = document.getElementById("controlPanel");
            var gp = document.getElementById("gamePanel");
            cp.width=cp.clientWidth;
            cp.height=cp.clientHeight;
            gp.width=gp.clientWidth;
            gp.height=gp.clientHeight; 
        }       
        var objs=[];
        const localhost = document.location.host;
        const objs_car = {};
        objs_car.obj_car=new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/Gt86_5000poly_closed.obj',false,'http://'+localhost+'/cg/Esame/3D/gt86/texture.bmp');
        objs_car.obj_wheel=new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/ruote/ruota.obj',false,'http://'+localhost+'/cg/Esame/3D/gt86/ruote/ruota.bmp');          
        objs_car.warning =new Obj3D('http://'+localhost+'/cg/Esame/3D/warning.obj'); 
        objs_car.warning.changeColor([1.0,0.0,0.0,1.0]);
        objs_car.crash=new Obj3D('http://'+localhost+'/cg/Esame/3D/crash.obj'); 
        objs_car.crash.changeColor([1.0,0.0,0.0,1.0]);

        const mondoFaceTexture = [];
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo1.bmp');        
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo2.bmp');        
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo3.bmp');        
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo4.bmp');        
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo5.bmp');        
        mondoFaceTexture.push('http://'+localhost+'/cg/Esame/3D/mondo/mondo6.bmp');
        var mondo = new Mondo(mondoFaceTexture);     
        var car = new Car(objs_car);        
        var pista = new Pista();
        var luceDaCampo_m1 =new Obj3D('http://'+localhost+'/cg/Esame/3D/luceDaCampo.obj');  
        var luceDaCampo_m2 =new Obj3D('http://'+localhost+'/cg/Esame/3D/luceDaCampo.obj');         
        var luceDaCampo_m3 =new Obj3D('http://'+localhost+'/cg/Esame/3D/luceDaCampo.obj');         
        var negozio =new Obj3D('http://'+localhost+'/cg/Esame/3D/negozio/Negozio.obj',false,'http://'+localhost+'/cg/Esame/3D/negozio/negozio.bmp');      
        var cartellone_mia_foto =new Obj3D('http://'+localhost+'/cg/Esame/3D/cartellone/cartello.obj',false,'http://'+localhost+'/cg/Esame/3D/cartellone/cartello.bmp');  
        cartellone_mia_foto.translate(-25,-1,5);
        cartellone_mia_foto.rotate(30,"y");
        negozio.mirror_bl=true;
        negozio.translate(0,0,0.18);        
        negozio.rotate(90,"y")
        luceDaCampo_m1.translate(-25,0,-5);   
        luceDaCampo_m1.rotate(200,"y");  
        luceDaCampo_m1.mirror_bl=true;             
        luceDaCampo_m2.translate(24,0,-15);                       
        luceDaCampo_m2.rotate(-30,"y");   
        luceDaCampo_m2.mirror_bl=true;             
        luceDaCampo_m3.translate(35,0,5);              
        luceDaCampo_m3.rotate(160,"y");     
        luceDaCampo_m3.mirror_bl=true;   
        
   

        //IMPORTANTE che la car sia il primo OBJ per far si che la camera sull'auto funzioni correttamente 
        //e anche per la selezione della modalità di gioco
        objs.push(car); 
        objs.push(mondo);
        objs.push(pista);
        objs.push(luceDaCampo_m1);           
        objs.push(luceDaCampo_m2);          
        objs.push(luceDaCampo_m3);       
        objs.push(negozio);       
        objs.push(cartellone_mia_foto);        
        var Game = new GameBehavior(car);//gestore dei punteggi 
        var GamePanel = new WebGLController(document.getElementById("gamePanel"),objs);        
        var ControlPanel = new Panel2D(document.getElementById("controlPanel"),GamePanel,Game);


    
        GamePanel.requestAnimationEnabled=true;
        ControlPanel.requestAnimationEnabled=true;
        dinamicResize();
        window.addEventListener("resize",dinamicResize);
    </script>
    <script type="text/javascript">
        //------------PER FACILITARE IL DEBUG
        window.render2D= ControlPanel.render;            
        window.renderGL= GamePanel.render;
        window.showParam=function(){
            console.log("------------------GamePanel.param----");
            console.log("settings",GamePanel.settings);
            console.log("------------------GamePanel.param----");
        }  
        window.ta=function(x,y,z){
            GamePanel.settings.cameraX=x;
            GamePanel.settings.cameraY=y;   
            GamePanel.settings.cameraZ=z;             
        }
        window.ebs=function(enable){
            GamePanel.blur_shadow=enable;
        }   
        //-----------------finisco la fase di setting
        GamePanel.fpsCounterFunction=function rsetFtpcounter(val){
            ControlPanel.fpscounter=Math.round(val);
        }
        ControlPanel.update();
        //aspetto che tutte le textur siano state caricate
        StartWhenReady(objs,function(){
                //genero la funzione che mi permette di capire se l'auto
                // è in pista o se è uscita (usata nei punteggi)
                //e la passo alla macchina
                car.pista_bound= pista.getFuncAppartieneAllaPista();
                // console.log("pista_bound-->",car.pista_bound);
                //la funzione seguente restituisce la funzione di validazione della posizione dell'auto
                //riferita agli oggetti di scena
                //ipedendo alla macchina di entrare dentro gli oggetti
                const array_objs_bound =[];
                //genero le funzioni che gestiscono gli ostacoli 
                array_objs_bound.push(mondo.getBound());   
                array_objs_bound.push(luceDaCampo_m1.getBound());        
                array_objs_bound.push(luceDaCampo_m2.getBound());        
                array_objs_bound.push(luceDaCampo_m3.getBound());            
                array_objs_bound.push(negozio.getBound());                  
                array_objs_bound.push(cartellone_mia_foto.getBound());
                //le unisco ed aggiungo anche uno "spessore" all'auto,
                //considerando dal baricentro un range di pixel
                //per alleggerire il carico esegui le funzioni di appartenenza discretizzando di 0.2 in 0.2
                //in sostanza gli oggetti più piccoli di 0.2 potrebbero passare attraverso alla macchina
                const range_x = 0.4;
                const range_y=1.0;
                car.obj_bound= function(x,y){
                        for(var i=0;i<array_objs_bound.length;i++){
                            for(var k = -range_x;k<range_x ;k+=0.2){
                                for(var j = -range_y;j<range_y ;j+=0.2){
                                    if(!array_objs_bound[i](x+k,y+j)){
                                        return false; //hai sbattuto contro qualcosa
                                    }
                                }
                            }
                           
                        }
                        return true;//tutto ok
                }
                //attivo la macchina
                car.enableKeyboard(true); //attivo i comandi da tastiera dell'auto        
                car.enableThouch(true, document.getElementById("gamePanel"));//per mobile
                car.active(true); //attivo il doStep dell'auto
                //aggiungo i comandi del mouse sul canvas del gioco per poter modificare la View 
                //(se di tipo free, non funzioneranno con la view di tipo dinamica, ovvero che segue l'auto)
                addMouseEventOnGame(document.getElementById("gamePanel"),GamePanel);//funzione presente in utility.js
                //attivo il render
                GamePanel.init();
                GamePanel.update();
                document.getElementById("loading").style.display="none";
        });
    </script>

    
</html>