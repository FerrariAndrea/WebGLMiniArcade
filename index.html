<!doctype html>
<html>
  <head>
        <!-- Sprint1
            Caricamento oggetto 3d da file
            Gestione luce
            Gestione colori
            Gestione trasformazioni geometriche sull'oggetto
            Gestione Camera, punto di vista
            ----------------------------------------------
            esempi utilizzati:
            Esercizio8 CubeMeshObj
            WebGl_code3/cg_car2.html
            WebGl_code2/webgl-3d-lighting-point.html
            WebGl_code2/gc_webgl-multiple-objects-list
         -->
        <!-- Sprint2 (NON FINITO)
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/cube_shading
         -->
        <!-- Sprint3 
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/webgl-shadows-w-spot-light
         -->

      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <link rel="stylesheet" type="text/css" href="css/style.css">
      <title>WebGLMiniArcade</title> 

      
   </head>
   
    <body>
        <div id="container" >            
            <canvas id="gamePanel"></canvas>
            <canvas id="controlPanel"></canvas>
        </div>       
        <div id="loading">
                <h1>CARICAMENTO IN CORSO...</h1>
        </div>

        <!-- WebGLControllerV2 -----INIZIO-->
       <script  id="3d-vertex-shader" type="x-shader/x-vertex">
            //uniform mat4 Mmatrix;   

            attribute vec4 a_position;
            attribute vec2 a_texcoord;
            attribute vec3 a_normal;
            
         
            uniform vec3 u_viewWorldPosition;
            uniform vec3 u_lightWorldPosition;


            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_world;
            uniform mat4 u_textureMatrix;

            varying vec2 v_texcoord;
            varying vec4 v_projectedTexcoord;
            varying vec3 v_normal;

            varying vec3 v_surfaceToLight;
            varying vec3 v_surfaceToView;


            //-------------------------------------------------------------------LUCI AUTO
            uniform vec3 u_lightWorldPosition_AD;
            varying vec3 v_surfaceToLight_AD;
            uniform vec3 u_lightWorldPosition_AS;
            varying vec3 v_surfaceToLight_AS;
            
         

            uniform vec3 u_lightWorldPosition_AD_sup;
            varying vec3 v_surfaceToLight_AD_sup;
            uniform vec3 u_lightWorldPosition_AS_sup;
            varying vec3 v_surfaceToLight_AS_sup;

            uniform vec3 u_lightWorldPosition_PD_sup;            
            uniform vec3 u_lightWorldPosition_PS_sup;            
            varying vec3 v_surfaceToLight_PS_sup;            
            varying vec3 v_surfaceToLight_PD_sup;

            //ombre
            uniform mat4 u_textureMatrix_1;            
            varying vec4 v_projectedTexcoord_1;            
            uniform mat4 u_textureMatrix_2;            
            varying vec4 v_projectedTexcoord_2;            
            uniform mat4 u_textureMatrix_3;            
            varying vec4 v_projectedTexcoord_3;            
            uniform mat4 u_textureMatrix_4;            
            varying vec4 v_projectedTexcoord_4;                     
            uniform mat4 u_textureMatrix_5;            
            varying vec4 v_projectedTexcoord_5;         
            uniform mat4 u_textureMatrix_6;            
            varying vec4 v_projectedTexcoord_6;
            //----------------------------------------------------------------------------

            void main() {
            // Multiply the position by the matrix.
            vec4 worldPosition = u_world * a_position;

            gl_Position = u_projection * u_view * worldPosition;
            //gl_Position = u_projection * u_view * Mmatrix * worldPosition;

            // Pass the texture coord to the fragment shader.
            v_texcoord = a_texcoord;

            v_projectedTexcoord = u_textureMatrix * worldPosition;

            // orient the normals and pass to the fragment shader
            v_normal = mat3(u_world) * a_normal;

            // compute the world position of the surface
            vec3 surfaceWorldPosition = (u_world * a_position).xyz;

            // compute the vector of the surface to the light
            // and pass it to the fragment shader
            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
            // compute the vector of the surface to the view/camera
            // and pass it to the fragment shader
            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;

            //-------------------------------------------------------------------LUCI AUTO
            v_surfaceToLight_AD = u_lightWorldPosition_AD - surfaceWorldPosition;
            v_surfaceToLight_AS = u_lightWorldPosition_AS - surfaceWorldPosition;
            v_surfaceToLight_AD_sup = u_lightWorldPosition_AD_sup - surfaceWorldPosition;
            v_surfaceToLight_AS_sup = u_lightWorldPosition_AS_sup - surfaceWorldPosition;
            v_surfaceToLight_PD_sup = u_lightWorldPosition_PD_sup - surfaceWorldPosition;
            v_surfaceToLight_PS_sup = u_lightWorldPosition_PS_sup - surfaceWorldPosition;
            //---ombre
            v_projectedTexcoord_1 = u_textureMatrix_1 * worldPosition;            
            v_projectedTexcoord_2 = u_textureMatrix_2 * worldPosition;
            v_projectedTexcoord_3 = u_textureMatrix_3 * worldPosition;
            v_projectedTexcoord_4 = u_textureMatrix_4 * worldPosition;
            v_projectedTexcoord_5 = u_textureMatrix_5 * worldPosition;
            v_projectedTexcoord_6 = u_textureMatrix_6 * worldPosition;
            //----------------------------------------------------------------------------

            }
            </script>
            <!-- fragment shader -->
            <script  id="3d-fragment-shader" type="x-shader/x-fragment">
            precision mediump float;


            // Passed in from the vertex shader.
            varying vec2 v_texcoord;
            varying vec4 v_projectedTexcoord;
            varying vec3 v_normal;
            varying vec3 v_surfaceToLight;
            varying vec3 v_surfaceToView;
            uniform vec4 u_colorMult;
            uniform sampler2D u_texture;
            uniform sampler2D u_projectedTexture;        
            uniform float u_bias;
            uniform float u_shininess;

            uniform vec3 u_lightDirection; 

            uniform float blur_shadow;

            uniform float u_innerLimit;          // in dot space
            uniform float u_outerLimit;          // in dot space
            //
            uniform float illuminazione;

            //aggiunto per poter disegnare un oggetto senza texture
            uniform float texture_enable; 
            //aggiunto per poter calcolare un numero randomico 
            float rand(vec2 co){
                return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
            }

            //-------------------------------------------------------------------LUCI AUTO
            varying vec3 v_surfaceToLight_AD;        
            varying vec3 v_surfaceToLight_AS;  
            //uniform vec4 u_color_A;
            uniform float u_shininess_A;
            uniform vec4 u_lightColor_A;
            uniform vec4 u_lightColor_P;
            uniform vec3 u_specularColor_A;            
            uniform vec3 u_lightDirection_AS;                   
            uniform vec3 u_lightDirection_AD; 
            uniform float u_outerLimit_A;          
            uniform float u_innerLimit_A;    
            
            //superfice faro davanti
            varying vec3 v_surfaceToLight_AD_sup;
            varying vec3 v_surfaceToLight_AS_sup;
            uniform vec3 u_lightDirection_AD_sup;
            uniform vec3 u_lightDirection_AS_sup;
            //superfice faro posteriore
            varying vec3 v_surfaceToLight_PD_sup;
            varying vec3 v_surfaceToLight_PS_sup;
            uniform vec3 u_lightDirection_PD_sup;
            uniform vec3 u_lightDirection_PS_sup;

            //ombre
            uniform sampler2D u_projectedTexture_1;            
            varying vec4 v_projectedTexcoord_1;            
            uniform sampler2D u_projectedTexture_2;            
            varying vec4 v_projectedTexcoord_2;            
            uniform sampler2D u_projectedTexture_3;            
            varying vec4 v_projectedTexcoord_3;            
            uniform sampler2D u_projectedTexture_4;            
            varying vec4 v_projectedTexcoord_4;    
            uniform sampler2D u_projectedTexture_5;            
            varying vec4 v_projectedTexcoord_5;    
            uniform sampler2D u_projectedTexture_6;            
            varying vec4 v_projectedTexcoord_6;    

            //----------------------------------------------------------------------------

            void main() {
                // because v_normal is a varying it's interpolated
                // so it will not be a unit vector. Normalizing it
                // will make it a unit vector again
                vec3 normal = normalize(v_normal);

                vec3 surfaceToLightDirection = normalize(v_surfaceToLight);

                vec3 surfaceToViewDirection = normalize(v_surfaceToView);
                vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);  
                float dotFromDirection = dot(surfaceToLightDirection,-u_lightDirection);
                                            
                float limitRange = u_innerLimit - u_outerLimit;
                float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
                float light = inLight * dot(normal, surfaceToLightDirection);
                float specular = inLight * pow(dot(normal, halfVector), u_shininess);
    
                vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
                float currentDepth = projectedTexcoord.z + u_bias;
    
                bool inRange =
                    projectedTexcoord.x >= 0.0 &&
                    projectedTexcoord.x <= 1.0 &&
                    projectedTexcoord.y >= 0.0 &&
                    projectedTexcoord.y <= 1.0;
    
                // the 'r' channel has the depth values
                float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r ;
                float shadowLight_0 =(inRange && projectedDepth <= currentDepth) ? 1.0 : 0.0;
                float shadowLight=illuminazione-shadowLight_0;
                float shadowLight_1 =1.0;
                float shadowLight_2 =1.0;
                float shadowLight_3 =1.0;
                float shadowLight_4 =1.0;
                float shadowLight_5 =1.0;
                float shadowLight_6 =1.0;

                limitRange = (u_innerLimit_A - u_outerLimit_A);     
                if(blur_shadow<=0.0){
                    //solo se il blur delle ombre non è attivo
                    //ombre luci auto
                    //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione terreno)
                    projectedTexcoord = v_projectedTexcoord_1.xyz / v_projectedTexcoord_1.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;                                     
                    dotFromDirection = dot(normalize(v_surfaceToLight_AD),-u_lightDirection_AD);    
                    float smorzatore_luce=1.0;
                    if(dotFromDirection<0.0){                     
                        smorzatore_luce=0.0;
                    }else{
                        smorzatore_luce=clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    }
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_1 = texture2D(u_projectedTexture_1, projectedTexcoord.xy).r ;
                    shadowLight_1 =(inRange && projectedDepth_1 <= currentDepth) ? 1.0 : (1.0-smorzatore_luce);
                    if(!inRange ){
                        shadowLight_1= 1.0;
                    }
                    //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione terreno)
                    projectedTexcoord = v_projectedTexcoord_2.xyz / v_projectedTexcoord_2.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;              
                    dotFromDirection = dot(normalize(v_surfaceToLight_AS),-u_lightDirection_AS);    
                    if(dotFromDirection<0.0){                     
                        smorzatore_luce = 0.0;
                    }else{
                        smorzatore_luce=clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    }
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_2 = texture2D(u_projectedTexture_2, projectedTexcoord.xy).r ;
                    shadowLight_2 =(inRange && projectedDepth_2 <= currentDepth) ? 1.0 : (1.0-smorzatore_luce);
                    if(!inRange){
                        shadowLight_2= 1.0;
                    }
                    //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione faro stesso)    
                    projectedTexcoord = v_projectedTexcoord_3.xyz / v_projectedTexcoord_3.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_3 = texture2D(u_projectedTexture_3, projectedTexcoord.xy).r ;
                    shadowLight_3 =(inRange && projectedDepth_3 <= currentDepth) ? 1.0 : 0.0;
                    if(!inRange){
                        shadowLight_3= 1.0;
                    }
                    //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione faro stesso)
                    projectedTexcoord = v_projectedTexcoord_4.xyz / v_projectedTexcoord_4.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_4 = texture2D(u_projectedTexture_4, projectedTexcoord.xy).r ;
                    shadowLight_4 =(inRange && projectedDepth_4 <= currentDepth) ? 1.0 : 0.0;
                    if(!inRange){
                        shadowLight_4= 1.0;
                    }
                    //-------------------------------------------------------------------LUCE AUTO DESTRA POSTERIORE (proiezione faro stesso)    
                    projectedTexcoord = v_projectedTexcoord_5.xyz / v_projectedTexcoord_5.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_5 = texture2D(u_projectedTexture_5, projectedTexcoord.xy).r ;
                    shadowLight_5 =(inRange && projectedDepth_5 <= currentDepth) ? 1.0 : 0.0;
                    if(!inRange){
                        shadowLight_5= 1.0;
                    }
                    //-------------------------------------------------------------------LUCE AUTO SINISTRA POSTERIORE (proiezione faro stesso)
                    projectedTexcoord = v_projectedTexcoord_6.xyz / v_projectedTexcoord_6.w;
                    inRange =
                        projectedTexcoord.x >= 0.0 &&
                        projectedTexcoord.x <= 1.0 &&
                        projectedTexcoord.y >= 0.0 &&
                        projectedTexcoord.y <= 1.0 && 
                        projectedTexcoord.z >= 0.0 && 
                        projectedTexcoord.z <= 1.0 
                        ;
                    currentDepth = projectedTexcoord.z + u_bias;
                    float projectedDepth_6 = texture2D(u_projectedTexture_6, projectedTexcoord.xy).r ;
                    shadowLight_6 =(inRange && projectedDepth_6 <= currentDepth) ? 1.0 : 0.0;
                    if(!inRange){
                        shadowLight_6= 1.0;
                    }
                    //---------------------------------------------------------------------------------------------------
                    shadowLight=illuminazione+ ( - shadowLight_1 * 0.2  - shadowLight_2 * 0.2 - shadowLight_0 * 0.6);
                }
                

                if(blur_shadow > 0.0){
                    //blur manuale delle ombre
                    //if(shadowLight>0.0){
                    //    //se il punto attuale non è un pezzo dell'ombra, aumento comunque la sua ombra in base alla distanza da altri px in ombra
                    //    float intensita = 0.0;
                    //    for(float x=0.0 ; x<0.001; x += 0.01){
                    //        for(float y=0.0; y<0.001; y += 0.01){
                    //            if((projectedTexcoord.x + x) < 1.0 && (projectedTexcoord.y + y) < 1.0){                            
                    //                vec4 temp_coord=vec4(projectedTexcoord.x+x,projectedTexcoord.y+y,projectedTexcoord.z,1.0);
                    //                float projectedDepth_2=texture2D(u_projectedTexture, temp_coord.xy).r;
                    //                intensita += (inRange && projectedDepth_2 <= currentDepth) ? 1.0 : 0.001;
                    //            }
                    //        }
                    //    }
                    //    shadowLight=shadowLight-intensita;
                    //}
                    //Poisson Sampling
                    vec2 poissonDisk_0 = vec2( -0.94201624, -0.39906216 );
                    vec2 poissonDisk_1 = vec2( 0.94558609, -0.76890725 );
                    vec2 poissonDisk_2 =  vec2( -0.094184101, -0.92938870 );
                    vec2 poissonDisk_3 = vec2( 0.34495938, 0.29387760 );
                    //-------------poisson blur
                    if(shadowLight > 0.0){
                        for (int i=0;i<16;i++){
                            float index = rand(gl_FragCoord.xy);
                            float temp=0.0;
                            if(index>0.2){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_0/blur_shadow ).r - currentDepth;                   
                            }else if(index>0.4){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_1/blur_shadow ).r - currentDepth;
                            }else if(index>0.6){
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_2/blur_shadow ).r - currentDepth;
                            }else{
                                temp=texture2D( u_projectedTexture, projectedTexcoord.xy + poissonDisk_3/blur_shadow ).r - currentDepth;
                            }
                            if(temp<0.0){
                                shadowLight +=  temp  ;
                            }
                        }
                    }
                
                }
         
                //aggiunto da me per poter disegnare un oggetto senza texture
                vec4 texColor = (texture_enable==0.0) ? (u_colorMult) : (texture2D(u_texture, v_texcoord) * u_colorMult);    
                //vec4 texColor =  u_colorMult;
          
                gl_FragColor = vec4(
                    texColor.rgb * light * shadowLight +
                    specular * shadowLight,
                    texColor.a);
                

        
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione terreno)
                if(shadowLight_1 < 1.0){
      
                    //-------------------
                    vec3 surfaceToLightDirection_AD = normalize(v_surfaceToLight_AD);
                    halfVector = normalize(surfaceToLightDirection_AD + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AD,-u_lightDirection_AD);      
                    inLight = clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AD);
                   // if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A) ;  
                        gl_FragColor += vec4(texColor.rgb * u_lightColor_A.rgb * light  +  specular * u_specularColor_A,texColor.a);   
                   //}
                }
                   
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione terreno)
                if(shadowLight_2 < 1.0){
                    vec3 surfaceToLightDirection_AS = normalize(v_surfaceToLight_AS);
                    halfVector = normalize(surfaceToLightDirection_AS + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AS,-u_lightDirection_AS);   
                    inLight = clamp((dotFromDirection - u_outerLimit_A) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AS);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(texColor.rgb * u_lightColor_A.rgb * light +  specular * u_specularColor_A,texColor.a);
                    }
                }
                //-------------------------------------------------------------------LUCE AUTO DESTRA (proiezione faro stesso)
                if(shadowLight_3 < 1.0){
                    vec3 surfaceToLightDirection_AD_sup = normalize(v_surfaceToLight_AD_sup);
                    halfVector = normalize(surfaceToLightDirection_AD_sup + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AD_sup,- u_lightDirection_AD_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AD_sup);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                        gl_FragColor += vec4(u_lightColor_A.rgb * light +  specular * u_specularColor_A,u_lightColor_A.a);   
                    }
                }                
                //-------------------------------------------------------------------LUCE AUTO SINISTRA (proiezione faro stesso)
                if(shadowLight_4 < 1.0){
                    vec3 surfaceToLightDirection_AS_supp = normalize(v_surfaceToLight_AS_sup);
                    halfVector = normalize(surfaceToLightDirection_AS_supp + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_AS_supp,- u_lightDirection_AS_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_AS_supp);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(u_lightColor_A.rgb * light +  specular * u_specularColor_A,u_lightColor_A.a);
                    }
                } 
                //-------------------------------------------------------------------LUCE AUTO DESTRA POSTERIORE (proiezione faro stesso)
                if(shadowLight_5 < 1.0){
                    vec3 surfaceToLightDirection_PD_sup = normalize(v_surfaceToLight_PD_sup);
                    halfVector = normalize(surfaceToLightDirection_PD_sup + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_PD_sup,- u_lightDirection_PD_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_PD_sup);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                        gl_FragColor += vec4(u_lightColor_P.rgb * light*2.0 +  specular * u_specularColor_A,u_lightColor_P.a);   
                    }
                }                
                //-------------------------------------------------------------------LUCE AUTO SINISTRA POSTERIORE (proiezione faro stesso)
                if(shadowLight_6 < 1.0){
                    vec3 surfaceToLightDirection_PS_supp = normalize(v_surfaceToLight_PS_sup);
                    halfVector = normalize(surfaceToLightDirection_PS_supp + surfaceToViewDirection);
                    dotFromDirection = dot(surfaceToLightDirection_PS_supp,- u_lightDirection_PS_sup);         
                    limitRange = (0.9990 -  0.99144);       
                    inLight = clamp((dotFromDirection -  0.99144) / limitRange, 0.0, 1.0);
                    light = inLight * dot(normal, surfaceToLightDirection_PS_supp);
                    if (light > 0.0) {
                        specular = pow(dot(normal, halfVector), u_shininess_A);  
                         gl_FragColor += vec4(u_lightColor_P.rgb * light*2.0 +  specular * u_specularColor_A,u_lightColor_P.a);
                    }
                }
                //----------------------------------------------------------------------------
              
          
                //}
               
    
            }
          
            </script>
            <script id="color-vertex-shader" type="x-shader/x-vertex">
                //uniform mat4 Mmatrix; 

                attribute vec4 a_position;
                
                uniform mat4 u_projection;
                uniform mat4 u_view;
                uniform mat4 u_world;
                
                void main() {
                  // Multiply the position by the matrices.
                  gl_Position = u_projection * u_view * u_world * a_position;
                  //gl_Position = u_projection * u_view * Mmatrix * u_world * a_position;
                }
                </script>
                <!-- fragment shader -->
                <script id="color-fragment-shader" type="x-shader/x-fragment">
                precision mediump float;
                
                uniform vec4 u_color;
                void main() {
                  gl_FragColor = u_color;
                }
                </script>
        <!-- WebGLControllerV2 -----FINE-->
   
    </body>




    
    <script type="text/javascript" src="lib/utility.js"></script>
    <script type="text/javascript" src="lib/Panel2D.js"></script>
    <script type="text/javascript" src="lib/WebGLController.js"></script>    
    <script type="text/javascript" src="lib/Obj3D.js"></script>    
    <script type="text/javascript" src="lib/Obj3DClone.js"></script>    
    <script type="text/javascript" src="lib/Car.js"></script>    
    <script type="text/javascript" src="lib/Ombre.js"></script>

    <script type="text/javascript" src="resources/subdiv.js"></script>
  <script type="text/javascript" src="resources/mesh_utils.js"></script>
  <script type="text/javascript" src="resources/webgl-utils.js"></script>
  <script type="text/javascript" src="resources/m4.js"></script>      
  <script  type="text/javascript" src="resources/glm_light.js"></script>

  <script type="text/javascript" src="resources/primitives.js"></script>
  <script type="text/javascript" src="webgl-debug.js"></script>

    <script type="text/javascript">
        function dinamicResize(){
            var cp = document.getElementById("controlPanel");
            var gp = document.getElementById("gamePanel");
            cp.width=cp.clientWidth;
            cp.height=cp.clientHeight;
            gp.width=gp.clientWidth;
            gp.height=gp.clientHeight; 
        }       
        var ControlPanel = new Panel2D(document.getElementById("controlPanel"));
        var objs=[];
        //Gt86_5000poly_closed
        const localhost = document.location.host;
        const objs_car = {};
        objs_car.obj_car=new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/Gt86_5000poly_closed.obj',false,'http://'+localhost+'/cg/Esame/3D/gt86/texture.bmp');
        objs_car.obj_wheel=new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/ruote/ruota.obj')
        var car = new Car(objs_car);
        var cubo =new Obj3D('http://11.0.0.15/cg/Esame/3D/c_t.obj');
        cubo.translate(0,-1.0,0);
        //var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/pista.obj',true);
        // var cubo =new Obj3D('http://11.0.0.15/cg/Esame/3D/c.obj',true);
        //var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/m.obj',true);
        //car.translate(5,5,5);
        objs.push(car); 
        //objs.push(pista);
        objs.push(cubo);
        var GamePanel = new WebGLController(document.getElementById("gamePanel"),objs);
        car.enableThouch(true, document.getElementById("gamePanel"));
        GamePanel.requestAnimationEnabled=true;
        ControlPanel.requestAnimationEnabled=true;
        dinamicResize();
        window.addEventListener("resize",dinamicResize);
    </script>
    <script type="text/javascript">
        //PER FACILITARE IL DEBUG
        window.render2D= ControlPanel.render;            
        window.renderGL= GamePanel.render;
        window.showParam=function(){
            console.log("------------------GamePanel.param----");
            console.log("near",GamePanel.near);
            console.log("far",GamePanel.far);
            console.log("(??)radius",GamePanel.radius);
            console.log("(angolo y) theta°",radToDeg(GamePanel.theta));
            console.log("(angolo x) phi°",radToDeg(GamePanel.phi));
            console.log("(??)dr",GamePanel.dr);
            console.log("(asse z) fov",GamePanel.fov);
            console.log("------------------GamePanel.param----");
        }
        window.setParam=function(name,value,convertDegToRad=false,stamp=true){
            if(convertDegToRad){
                GamePanel[name]=degToRad(value);
            }else{
                GamePanel[name]=value;
            }           
            if(stamp){
                window.showParam();
            }
        }
        window.ta=function(x,y,z){
            car.posRel_faro_pd.x=x;
            car.posRel_faro_pd.y=y;
            car.posRel_faro_pd.z=z;
        }
        window.ebs=function(enable){
            GamePanel.blur_shadow=enable;
        }
        // window.setParam("phi",45,true);
        // window.setParam("theta",0.001,true);
        // window.setParam("far",2000);
        // window.setParam("fov",2000);        
        GamePanel.fpsCounterFunction=function rsetFtpcounter(val){
            ControlPanel.fpscounter=Math.round(val);
        }
        ControlPanel.update();
        StartWhenReady(objs,function(){
            GamePanel.init();
            GamePanel.update();
            document.getElementById("loading").style.display="none";
        });
    </script>

    
</html>