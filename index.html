<!doctype html>
<html>
  <head>
        <!-- Sprint1
            Caricamento oggetto 3d da file
            Gestione luce
            Gestione colori
            Gestione trasformazioni geometriche sull'oggetto
            Gestione Camera, punto di vista
            ----------------------------------------------
            esempi utilizzati:
            Esercizio8 CubeMeshObj
            WebGl_code3/cg_car2.html
            WebGl_code2/webgl-3d-lighting-point.html
            WebGl_code2/gc_webgl-multiple-objects-list
         -->
        <!-- Sprint2 (NON FINITO)
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/cube_shading
         -->
        <!-- Sprint3 
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/webgl-shadows-w-spot-light
         -->

      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <link rel="stylesheet" type="text/css" href="css/style.css">
      <title>WebGLMiniArcade</title> 

      
   </head>
   
    <body>
        <div id="container" >            
            <canvas id="gamePanel"></canvas>
            <canvas id="controlPanel"></canvas>
        </div>       
        <div id="loading">
                <h1>CARICAMENTO IN CORSO...</h1>
        </div>

        <!-- WebGLControllerV2 -----INIZIO-->
       <script  id="3d-vertex-shader" type="x-shader/x-vertex">
            //uniform mat4 Mmatrix;   

            attribute vec4 a_position;
            attribute vec2 a_texcoord;
            attribute vec3 a_normal;

            uniform vec3 u_lightWorldPosition;
            uniform vec3 u_viewWorldPosition;

            uniform mat4 u_projection;
            uniform mat4 u_view;
            uniform mat4 u_world;
            uniform mat4 u_textureMatrix;

            varying vec2 v_texcoord;
            varying vec4 v_projectedTexcoord;
            varying vec3 v_normal;

            varying vec3 v_surfaceToLight;
            varying vec3 v_surfaceToView;

            void main() {
            // Multiply the position by the matrix.
            vec4 worldPosition = u_world * a_position;

            gl_Position = u_projection * u_view * worldPosition;
            //gl_Position = u_projection * u_view * Mmatrix * worldPosition;

            // Pass the texture coord to the fragment shader.
            v_texcoord = a_texcoord;

            v_projectedTexcoord = u_textureMatrix * worldPosition;

            // orient the normals and pass to the fragment shader
            v_normal = mat3(u_world) * a_normal;

            // compute the world position of the surface
            vec3 surfaceWorldPosition = (u_world * a_position).xyz;

            // compute the vector of the surface to the light
            // and pass it to the fragment shader
            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

            // compute the vector of the surface to the view/camera
            // and pass it to the fragment shader
            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
            }
            </script>
            <!-- fragment shader -->
            <script  id="3d-fragment-shader" type="x-shader/x-fragment">
            precision mediump float;

            

            // Passed in from the vertex shader.
            varying vec2 v_texcoord;
            varying vec4 v_projectedTexcoord;
            varying vec3 v_normal;
            varying vec3 v_surfaceToLight;
            varying vec3 v_surfaceToView;

            uniform vec4 u_colorMult;
            uniform sampler2D u_texture;
            uniform sampler2D u_projectedTexture;
            uniform float u_bias;
            uniform float u_shininess;
            uniform vec3 u_lightDirection;
            uniform float u_innerLimit;          // in dot space
            uniform float u_outerLimit;          // in dot space

            //aggiunto da me per poter disegnare un oggetto senza texture
            uniform float texture_enable; 

            void main() {
            // because v_normal is a varying it's interpolated
            // so it will not be a unit vector. Normalizing it
            // will make it a unit vector again
            vec3 normal = normalize(v_normal);

            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
            vec3 surfaceToViewDirection = normalize(v_surfaceToView);
            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

            float dotFromDirection = dot(surfaceToLightDirection,
                                        -u_lightDirection);
            float limitRange = u_innerLimit - u_outerLimit;
            float inLight = clamp((dotFromDirection - u_outerLimit) / limitRange, 0.0, 1.0);
            float light = inLight * dot(normal, surfaceToLightDirection);
            float specular = inLight * pow(dot(normal, halfVector), u_shininess);

            vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
            float currentDepth = projectedTexcoord.z + u_bias;

            bool inRange =
                projectedTexcoord.x >= 0.0 &&
                projectedTexcoord.x <= 1.0 &&
                projectedTexcoord.y >= 0.0 &&
                projectedTexcoord.y <= 1.0;

            // the 'r' channel has the depth values
            float projectedDepth = texture2D(u_projectedTexture, projectedTexcoord.xy).r;
            float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

            //aggiunto da me per poter disegnare un oggetto senza texture
            vec4 texColor = (texture_enable==0.0) ? (u_colorMult) : (texture2D(u_texture, v_texcoord) * u_colorMult);

            //vec4 texColor =  u_colorMult;
            gl_FragColor = vec4(
                texColor.rgb * light * shadowLight +
                specular * shadowLight,
                texColor.a);
            }
            </script>
            <script id="color-vertex-shader" type="x-shader/x-vertex">
                //uniform mat4 Mmatrix; 

                attribute vec4 a_position;
                
                uniform mat4 u_projection;
                uniform mat4 u_view;
                uniform mat4 u_world;
                
                void main() {
                  // Multiply the position by the matrices.
                  gl_Position = u_projection * u_view * u_world * a_position;
                  //gl_Position = u_projection * u_view * Mmatrix * u_world * a_position;
                }
                </script>
                <!-- fragment shader -->
                <script id="color-fragment-shader" type="x-shader/x-fragment">
                precision mediump float;
                
                uniform vec4 u_color;
                void main() {
                  gl_FragColor = u_color;
                }
                </script>
        <!-- WebGLControllerV2 -----FINE-->
   
    </body>




    
    <script type="text/javascript" src="lib/utility.js"></script>
    <script type="text/javascript" src="lib/Panel2D.js"></script>
    <script type="text/javascript" src="lib/WebGLController.js"></script>    
    <script type="text/javascript" src="lib/Obj3D.js"></script>    
    <script type="text/javascript" src="lib/Obj3DClone.js"></script>    
    <script type="text/javascript" src="lib/Car.js"></script>

    <script type="text/javascript" src="resources/subdiv.js"></script>
  <script type="text/javascript" src="resources/mesh_utils.js"></script>
  <script type="text/javascript" src="resources/webgl-utils.js"></script>
  <script type="text/javascript" src="resources/m4.js"></script>      
  <script  type="text/javascript" src="resources/glm_light.js"></script>

  <script type="text/javascript" src="resources/primitives.js"></script>
  <script type="text/javascript" src="webgl-debug.js"></script>

    <script type="text/javascript">
        function dinamicResize(){
            var cp = document.getElementById("controlPanel");
            var gp = document.getElementById("gamePanel");
            cp.width=cp.clientWidth;
            cp.height=cp.clientHeight;
            gp.width=gp.clientWidth;
            gp.height=gp.clientHeight; 
        }       
        var ControlPanel = new Panel2D(document.getElementById("controlPanel"));
        var objs=[];
        //Gt86_5000poly_closed
        const localhost = document.location.host;
        var scocca =new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/Gt86_5000poly_closed.obj',false,'http://'+localhost+'/cg/Esame/3D/gt86/texture.bmp');
        var ruota =new Obj3D('http://'+localhost+'/cg/Esame/3D/gt86/ruote/ruota.obj');
       
        var car = new Car(scocca,ruota);
        // var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/c_t.obj');
        //var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/pista.obj',true);
        // var cubo =new Obj3D('http://11.0.0.15/cg/Esame/3D/c.obj',true);
        //var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/m.obj',true);
        //car.translate(5,5,5);
        objs.push(car); 
        //objs.push(pista);
        //objs.push(cubo);
        var GamePanel = new WebGLController(document.getElementById("gamePanel"),objs);
        car.enableThouch(true, document.getElementById("gamePanel"));
        GamePanel.requestAnimationEnabled=true;
        ControlPanel.requestAnimationEnabled=true;
        dinamicResize();
        window.addEventListener("resize",dinamicResize);
    </script>
    <script type="text/javascript">
        //PER FACILITARE IL DEBUG
        window.render2D= ControlPanel.render;            
        window.renderGL= GamePanel.render;
        window.showParam=function(){
            console.log("------------------GamePanel.param----");
            console.log("near",GamePanel.near);
            console.log("far",GamePanel.far);
            console.log("(??)radius",GamePanel.radius);
            console.log("(angolo y) theta°",radToDeg(GamePanel.theta));
            console.log("(angolo x) phi°",radToDeg(GamePanel.phi));
            console.log("(??)dr",GamePanel.dr);
            console.log("(asse z) fov",GamePanel.fov);
            console.log("------------------GamePanel.param----");
        }
        window.setParam=function(name,value,convertDegToRad=false,stamp=true){
            if(convertDegToRad){
                GamePanel[name]=degToRad(value);
            }else{
                GamePanel[name]=value;
            }           
            if(stamp){
                window.showParam();
            }
        }
        window.ta=function(x,y,z){
            car.translate(x,y,z);
        }
        window.r=function(g,d){
            car.rotate(g,d);
        }
        // window.setParam("phi",45,true);
        // window.setParam("theta",0.001,true);
        // window.setParam("far",2000);
        // window.setParam("fov",2000);        
        GamePanel.fpsCounterFunction=function rsetFtpcounter(val){
            ControlPanel.fpscounter=Math.round(val);
        }
        ControlPanel.update();
        StartWhenReady(objs,function(){
            GamePanel.init();
            GamePanel.update();
            document.getElementById("loading").style.display="none";
        });
    </script>

    
</html>