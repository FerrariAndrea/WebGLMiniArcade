<!doctype html>
<html>
  <head>
        <!-- Sprint1
            Caricamento oggetto 3d da file
            Gestione luce
            Gestione colori
            Gestione trasformazioni geometriche sull'oggetto
            Gestione Camera, punto di vista
            ----------------------------------------------
            esempi utilizzati:
            Esercizio8 CubeMeshObj
            WebGl_code3/cg_car2.html
            WebGl_code2/webgl-3d-lighting-point.html
            WebGl_code2/gc_webgl-multiple-objects-list
         -->
        <!-- Sprint2 (NON FINITO)
            Gestione shading
             ----------------------------------------------
            esempi utilizzati:
            WebGl_code2/cube_shading
         -->

      <!--per ricaricare sempre la pagina da zero e non usare la cache-->
      <META HTTP-EQUIV=”Pragma” CONTENT=”no-cache”>
      <META HTTP-EQUIV=”Cache-Control” CONTENT=”no-cache”>
      <link rel="stylesheet" type="text/css" href="css/style.css">
      <title>WebGLMiniArcade</title> 

      
   </head>
   
    <body>
        <div id="container" >            
            <canvas id="gamePanel"></canvas>
            <canvas id="controlPanel"></canvas>
        </div>      

  
        <!-- WebGLController -----INIZIO-->
        <script id="vertex-shader" type="x-shader/x-vertex">
            attribute  vec4 vPosition;
            attribute  vec3 vColor;
            varying vec4 fColor;
            
            uniform mat4 Mmatrix;
            //uniform mat4 modelView; //modelViewMatrix
            //uniform mat4 projection; //projectionMatrix
            
            //uniform mat4 u_worldViewProjection;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            
            //luce
            uniform mat4 u_world;
            attribute vec3 a_normal;
            uniform vec3 u_lightWorldPosition; //lightPosition
            varying vec3 v_normal;
            varying vec3 v_surfaceToLight;
            uniform mat4 u_worldInverseTranspose;
            
            //shading
            uniform vec4 ambientProduct, diffuseProduct, specularProduct;
            uniform float shininess;

            void main() 
            {

                //luce
                // orient the normals and pass to the fragment shader
                v_normal = mat3(u_world) * a_normal;
                // compute the world position of the surfoace
                vec3 surfaceWorldPosition = (u_world * vPosition).xyz;
                // compute the vector of the surface to the light
                // and pass it to the fragment shader
                v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

                vec3 pos = -(modelViewMatrix * vPosition).xyz;
    
                //fixed light postion
                
                vec3 light = u_lightWorldPosition.xyz;
                vec3 L = normalize( light - pos );
            
                
                vec3 E = normalize( -pos );
                vec3 H = normalize( L + E );
                
                vec4 NN = vec4(v_normal,0);
            
                // Transform vertex normal into eye coordinates
                   
                vec3 N = normalize( (modelViewMatrix*NN).xyz);
            
                // Compute terms in the illumination equation
                vec4 ambient = ambientProduct;
            
                float Kd = max( dot(L, N), 0.0 );
                vec4  diffuse = Kd*diffuseProduct;
            
                float Ks = pow( max(dot(N, H), 0.0), shininess );
                vec4  specular = Ks * specularProduct;
                
                if( dot(L, N) < 0.0 ) {
                specular = vec4(0.0, 0.0, 0.0, 1.0);
                }     

                gl_Position = projectionMatrix*modelViewMatrix*Mmatrix*vPosition;
                //fColor =vec4(vColor, 1.0);
                fColor = ambient + diffuse + specular;

            } 
        </script>            
        <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;            
        varying vec4 fColor;   
        
        
        //luce
        // Passed in from the vertex shader.
        varying vec3 v_normal;
        varying vec3 v_surfaceToLight;

        void
        main()
        {
            // because v_normal is a varying it's interpolated
            // so it will not be a unit vector. Normalizing it
            // will make it a unit vector again
            vec3 normal = normalize(v_normal);

            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);

            float light = dot(normal, surfaceToLightDirection);

            gl_FragColor = fColor;

            // Lets multiply just the color portion (not the alpha)
            // by the light
            gl_FragColor.rgb *= light;
        }
        </script>
        <!-- WebGLController -----FINE-->
    </body>




    
    <script type="text/javascript" src="lib/utility.js"></script>
    <script type="text/javascript" src="lib/Panel2D.js"></script>
    <script type="text/javascript" src="lib/WebGLController.js"></script>    
    <script type="text/javascript" src="lib/Obj3D.js"></script>

  <script type="text/javascript" src="resources/subdiv.js"></script>
  <script type="text/javascript" src="resources/mesh_utils.js"></script>
  <script type="text/javascript" src="resources/webgl-utils.js"></script>
  <script type="text/javascript" src="resources/m4.js"></script>      
  <script  type="text/javascript" src="resources/glm_light.js"></script>

  <script type="text/javascript" src="primitives.js"></script>
  <script type="text/javascript" src="webgl-debug.js"></script>

    <script type="text/javascript">
        function dinamicResize(){
            var cp = document.getElementById("controlPanel");
            var gp = document.getElementById("gamePanel");
            cp.width=cp.clientWidth;
            cp.height=cp.clientHeight;
            gp.width=gp.clientWidth;
            gp.height=gp.clientHeight; 
        }       
        var ControlPanel = new Panel2D(document.getElementById("controlPanel"));
        var objs=[];
        var car =new Obj3D('http://11.0.0.15/cg/Esame/3D/gt86/Gt86_5000poly_closed.obj');
        // var pista =new Obj3D('http://11.0.0.15/cg/Esame/3D/pista.obj',true);
        // var cubo =new Obj3D('http://11.0.0.15/cg/Esame/3D/c.obj',true);
        objs.push(car);   
        //objs.push(pista);
        //objs.push(cubo);
        var GamePanel = new WebGLController(document.getElementById("gamePanel"),objs);
        GamePanel.requestAnimationEnabled=true;
        dinamicResize();
        window.addEventListener("resize",dinamicResize);
    </script>
    <script type="text/javascript">
        //PER FACILITARE IL DEBUG
        window.render2D= ControlPanel.render;            
        window.renderGL= GamePanel.render;
        window.showParam=function(){
            console.log("------------------GamePanel.param----");
            console.log("near",GamePanel.near);
            console.log("far",GamePanel.far);
            console.log("(??)radius",GamePanel.radius);
            console.log("(angolo y) theta°",radToDeg(GamePanel.theta));
            console.log("(angolo x) phi°",radToDeg(GamePanel.phi));
            console.log("(??)dr",GamePanel.dr);
            console.log("(asse z) fov",GamePanel.fov);
            console.log("------------------GamePanel.param----");
        }
        window.setParam=function(name,value,convertDegToRad=false,stamp=true){
            if(convertDegToRad){
                GamePanel[name]=degToRad(value);
            }else{
                GamePanel[name]=value;
            }           
            if(stamp){
                window.showParam();
            }
        }
        window.ta=function(x,y,z){
            car.translate(x,y,z);
        }
         window.setParam("phi",45,true);
         window.setParam("theta",0.001,true);
         window.setParam("far",2000);
         window.setParam("fov",2000);
        ControlPanel.render();
        StartWhenReady(objs,function(){GamePanel.render();});
    </script>

    
</html>